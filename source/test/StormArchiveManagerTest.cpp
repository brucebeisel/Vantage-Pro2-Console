/*
 * Copyright (C) 2025 Bruce Beisel
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
#include <string.h>
#include <iostream>
#include "VantageWeatherStation.h"
#include "StormArchiveManager.h"
#include "GraphDataRetriever.h"
#include "SerialPort.h"
#include "VantageLogger.h"
#include "VantageDecoder.h"
#include "BaudRate.h"

using namespace vws;
using namespace std;


/*
static const unsigned char testBuffer1[] = {
    0x09, 0x00, 0x8f, 0x00, 0x9f, 0x00, 0x03, 0x00, 0x4f, 0x00, 0x1a, 0x00, 0x02, 0x00, 0x05, 0x00, //  16
    0x0c, 0x00, 0x2d, 0x00, 0x0f, 0x00, 0x49, 0x00, 0x02, 0x00, 0x04, 0x00, 0x1b, 0x00, 0x1e, 0x00, //  32
    0x26, 0x00, 0x06, 0x00, 0x22, 0x00, 0x67, 0x00, 0xae, 0x00, 0x39, 0x00, 0xba, 0x00, 0x3f, 0x00, //  48
    0x00, 0x00, 0x98, 0x37, 0x98, 0x3b, 0x98, 0x3d, 0x18, 0x3f, 0x98, 0x40, 0x98, 0x45, 0x98, 0x4a, //  64
    0x98, 0x52, 0x18, 0x53, 0x18, 0x55, 0x18, 0x56, 0x98, 0x57, 0x98, 0x58, 0x18, 0x59, 0x18, 0x5c, //  80
    0x98, 0x5d, 0x98, 0x5e, 0x98, 0x62, 0x98, 0x65, 0x18, 0x67, 0x18, 0x31, 0x18, 0x32, 0x18, 0x33, //  96
    0x98, 0x34, 0xff, 0xff, 0x18, 0x38, 0x98, 0x3b, 0x18, 0x3e, 0x98, 0x3f, 0x18, 0x42, 0x18, 0x46, // 112
    0x98, 0x4a, 0x98, 0x52, 0x98, 0x53, 0x18, 0x55, 0x18, 0x56, 0x98, 0x57, 0x98, 0x58, 0x18, 0x59, // 128
    0x18, 0x5c, 0x18, 0x5e, 0x18, 0x5f, 0x18, 0x63, 0x98, 0x65, 0x98, 0x67, 0x18, 0x31, 0x98, 0x32, // 144
    0x98, 0x33, 0x18, 0x35, 0xff, 0xff, 0xc4, 0x86                                                  // 152
};
*/

// 2024-03-02 to 2024-06-14
static const unsigned char testBuffer2[] = {
    // Rainfall
    0x09, 0x00, 0x8f, 0x00, 0x9f, 0x00, 0x03, 0x00, 0x4f, 0x00, //  10
    0x1a, 0x00, 0x02, 0x00, 0x05, 0x00, 0x0c, 0x00, 0x2d, 0x00, //  20
    0x0f, 0x00, 0x49, 0x00, 0x02, 0x00, 0x04, 0x00, 0x1b, 0x00, //  30
    0x1e, 0x00, 0x26, 0x00, 0x06, 0x00, 0x22, 0x00, 0x67, 0x00, //  40
    0xae, 0x00, 0x39, 0x00, 0xba, 0x00, 0x3f, 0x00, 0x00, 0x00, //  50

    // Storm Start
    0x98, 0x37, 0x98, 0x3b, 0x98, 0x3d, 0x18, 0x3f, 0x98, 0x40, //  60
    0x98, 0x45, 0x98, 0x4a, 0x98, 0x52, 0x18, 0x53, 0x18, 0x55, //  70
    0x18, 0x56, 0x98, 0x57, 0x98, 0x58, 0x18, 0x59, 0x18, 0x5c, //  80
    0x98, 0x5d, 0x98, 0x5e, 0x98, 0x62, 0x98, 0x65, 0x18, 0x67, //  90
    0x18, 0x31, 0x18, 0x32, 0x18, 0x33, 0x98, 0x34, 0xff, 0xff, // 100

    // Storm End
    0x18, 0x38, 0x98, 0x3b, 0x18, 0x3e, 0x98, 0x3f, 0x18, 0x42, // 110
    0x18, 0x46, 0x98, 0x4a, 0x98, 0x52, 0x98, 0x53, 0x18, 0x55, // 120
    0x18, 0x56, 0x98, 0x57, 0x98, 0x58, 0x18, 0x59, 0x18, 0x5c, // 130
    0x18, 0x5e, 0x18, 0x5f, 0x18, 0x63, 0x98, 0x65, 0x18, 0x67, // 140
    0x18, 0x31, 0x98, 0x32, 0x98, 0x33, 0x18, 0x35, 0xff, 0xff, // 150
    0xc4, 0x86                                                  // 152
};

// 2024-03-05 to 2024-06-27
static const unsigned char testBuffer3[] = {
    // Rainfall
    0x09, 0x00, 0x8f, 0x00, 0x9f, 0x00, 0x03, 0x00, 0x4f, 0x00,
    0x1a, 0x00, 0x02, 0x00, 0x05, 0x00, 0x0c, 0x00, 0x2d, 0x00,
    0x0f, 0x00, 0x49, 0x00, 0x02, 0x00, 0x04, 0x00, 0x1b, 0x00,
    0x1e, 0x00, 0x26, 0x00, 0x06, 0x00, 0x22, 0x00, 0x67, 0x00,
    0x3a, 0x00, 0x39, 0x00, 0xba, 0x00, 0x3f, 0x00, 0x00, 0x00,

    // Storm Start
    0x98, 0x37, 0x98, 0x3b, 0x98, 0x3d, 0x18, 0x3f, 0x98, 0x40,
    0x98, 0x45, 0x98, 0x4a, 0x98, 0x52, 0x18, 0x53, 0x18, 0x55,
    0x18, 0x56, 0x98, 0x57, 0x98, 0x58, 0x18, 0x59, 0x18, 0x5c,
    0x98, 0x5d, 0x98, 0x5e, 0x98, 0x62, 0x98, 0x65, 0x18, 0x67,
    0x18, 0x6d, 0x18, 0x32, 0x18, 0x33, 0x98, 0x34, 0xff, 0xff,

    // Storm End
    0x18, 0x38, 0x98, 0x3b, 0x18, 0x3e, 0x98, 0x3f, 0x18, 0x42,
    0x18, 0x46, 0x98, 0x4a, 0x98, 0x52, 0x98, 0x53, 0x18, 0x55,
    0x18, 0x56, 0x98, 0x57, 0x98, 0x58, 0x18, 0x59, 0x18, 0x5c,
    0x18, 0x5e, 0x18, 0x5f, 0x18, 0x63, 0x98, 0x65, 0x98, 0x67,
    0x98, 0x6d, 0x98, 0x32, 0x98, 0x33, 0x18, 0x35, 0xff, 0xff,

    // CRC
    0x6a, 0xb2
};



static const unsigned char * testBufferToUse = NULL;

namespace vws {
VantageWeatherStation::VantageWeatherStation(SerialPort & sp, int apm, Rainfall rcs) : serialPort(sp),
                                                                                       archivePeriodMinutes(apm),
                                                                                       consoleType(VANTAGE_PRO_2),
                                                                                       archivingActive(true),
                                                                                       rainCollectorSize(rcs),
                                                                                       logger(VantageLogger::getLogger("VantageWeatherStation")) {
}

VantageWeatherStation::~VantageWeatherStation() {

}

bool
VantageWeatherStation::eepromBinaryRead(unsigned address, unsigned count, char * output) {
    if (testBufferToUse == NULL)
        return false;

    memcpy(output, testBufferToUse, count);
    return true;
}

void
VantageWeatherStation::processRainCollectorSizeChange(Rainfall bucketSize) {
    rainCollectorSize = bucketSize;
}

void
VantageWeatherStation::consoleConnected() {
}

void
VantageWeatherStation::consoleDisconnected() {
}
}

int
main(int argc, char * argv[]) {
    VantageLogger::setLogLevel(VantageLogger::VANTAGE_DEBUG3);
    VantageDecoder::setRainCollectorSize(.01);
    SerialPort port("device", vws::BaudRate::BR_19200);
    VantageWeatherStation station(port);
    GraphDataRetriever gdr(station);
    StormArchiveManager sam(".", gdr);
    testBufferToUse = testBuffer2;
    sam.updateArchive();

    DateTimeFields min;
    min.setDate(2024, 1, 1);
    DateTimeFields max;
    max.setDate(2024, 12, 31);

    cout << "Testing queryStorms()" << endl;
    std::vector<StormData> list;
    DateTimeFields last = sam.queryStorms(min, max, list);
    cout << "Retrieved " << list.size() << " storms with max start of " << last.formatDate() << endl;
    int lastCount = list.size();

    cout << StormArchiveManager::formatStormJSON(list) << endl;

    cout << "Testing second archive update with same data" << endl;
    sam.updateArchive();

    last = sam.queryStorms(min, max, list);

    if (list.size() == lastCount)
        cout << "PASSED: Second update yielded same number of storms in the archive" << endl;
    else
        cout << "FAILED: Second update yielded a different number of storms in the archive. Old = " << lastCount << " New: " << list.size() << endl;

    testBufferToUse = testBuffer3;
    sam.updateArchive();

    min.setDate(2024, 3, 31);
    max.setDate(2024, 5, 30);
    last = sam.queryStorms(min, max, list);

    if (list.size() == 13)
        cout << "PASSED: Query of 2024-03-31 to 2024-05-30 yielded 13 storms" << endl;
    else
        cout << "FAILED: Query of 2024-03-31 to 2024-05-30 did not yield 13 storms, but " << list.size() << " storms" << endl;

    min.setDate(2024, 4, 1);
    max.setDate(2024, 5, 18);
    last = sam.queryStorms(min, max, list);

    if (list.size() == 10)
        cout << "PASSED: Query of 2024-04-01 to 2024-05-18 yielded 10 storms" << endl;
    else
        cout << "FAILED: Query of 2024-04-01 to 2024-05-18 did not yield 10 storms, but " << list.size() << " storms" << endl;
}
